"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@capacitor";
exports.ids = ["vendor-chunks/@capacitor"];
exports.modules = {

/***/ "(ssr)/./node_modules/@capacitor/core/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@capacitor/core/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Capacitor: () => (/* binding */ Capacitor),\n/* harmony export */   CapacitorCookies: () => (/* binding */ CapacitorCookies),\n/* harmony export */   CapacitorException: () => (/* binding */ CapacitorException),\n/* harmony export */   CapacitorHttp: () => (/* binding */ CapacitorHttp),\n/* harmony export */   ExceptionCode: () => (/* binding */ ExceptionCode),\n/* harmony export */   WebPlugin: () => (/* binding */ WebPlugin),\n/* harmony export */   WebView: () => (/* binding */ WebView),\n/* harmony export */   buildRequestInit: () => (/* binding */ buildRequestInit),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin)\n/* harmony export */ });\n/*! Capacitor: https://capacitorjs.com/ - MIT License */\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code, data) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        this.data = data;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    const getPlatform = () => {\n        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);\n    };\n    const isNativePlatform = () => getPlatform() !== 'web';\n    const isPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };\n    const handleError = (err) => win.console.error(err);\n    const registeredPlugins = new Map();\n    const registerPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then((impl) => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair âœ¨\n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise((resolve) => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),\n        });\n        return proxy;\n    };\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = (filePath) => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof global !== 'undefined'\n                ? global\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor() {\n        this.listeners = {};\n        this.retainedEventArguments = {};\n        this.windowListeners = {};\n    }\n    addListener(eventName, listenerFunc) {\n        let firstListener = false;\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n            firstListener = true;\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        if (firstListener) {\n            this.sendRetainedArgumentsForEvent(eventName);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data, retainUntilConsumed) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            if (retainUntilConsumed) {\n                let args = this.retainedEventArguments[eventName];\n                if (!args) {\n                    args = [];\n                }\n                args.push(data);\n                this.retainedEventArguments[eventName] = args;\n            }\n            return;\n        }\n        listeners.forEach((listener) => listener(data));\n    }\n    hasListeners(eventName) {\n        var _a;\n        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: (event) => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n    sendRetainedArgumentsForEvent(eventName) {\n        const args = this.retainedEventArguments[eventName];\n        if (!args) {\n            return;\n        }\n        delete this.retainedEventArguments[eventName];\n        args.forEach((arg) => {\n            this.notifyListeners(eventName, arg);\n        });\n    }\n}\n\nconst WebView = /*#__PURE__*/ registerPlugin('WebView');\n/******** END WEB VIEW PLUGIN ********/\n/******** COOKIES PLUGIN ********/\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nconst encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nconst decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\nclass CapacitorCookiesPluginWeb extends WebPlugin {\n    async getCookies() {\n        const cookies = document.cookie;\n        const cookieMap = {};\n        cookies.split(';').forEach((cookie) => {\n            if (cookie.length <= 0)\n                return;\n            // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n            key = decode(key).trim();\n            value = decode(value).trim();\n            cookieMap[key] = value;\n        });\n        return cookieMap;\n    }\n    async setCookie(options) {\n        try {\n            // Safely Encoded Key/Value\n            const encodedKey = encode(options.key);\n            const encodedValue = encode(options.value);\n            // Clean & sanitize options\n            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n            const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';\n            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async deleteCookie(options) {\n        try {\n            document.cookie = `${options.key}=; Max-Age=0`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearCookies() {\n        try {\n            const cookies = document.cookie.split(';') || [];\n            for (const cookie of cookies) {\n                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearAllCookies() {\n        try {\n            await this.clearCookies();\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n}\nconst CapacitorCookies = registerPlugin('CapacitorCookies', {\n    web: () => new CapacitorCookiesPluginWeb(),\n});\n// UTILITY FUNCTIONS\n/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nconst readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach((str) => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nconst buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (const key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') || typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n// WEB IMPLEMENTATION\nclass CapacitorHttpPluginWeb extends WebPlugin {\n    /**\n     * Perform an Http request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async request(options) {\n        const requestInit = buildRequestInit(options, options.webFetchExtra);\n        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n        const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n        const response = await fetch(url, requestInit);\n        const contentType = response.headers.get('content-type') || '';\n        // Default to 'text' responseType so no parsing happens\n        let { responseType = 'text' } = response.ok ? options : {};\n        // If the response content-type is json, force the response to be json\n        if (contentType.includes('application/json')) {\n            responseType = 'json';\n        }\n        let data;\n        let blob;\n        switch (responseType) {\n            case 'arraybuffer':\n            case 'blob':\n                blob = await response.blob();\n                data = await readBlobAsBase64(blob);\n                break;\n            case 'json':\n                data = await response.json();\n                break;\n            case 'document':\n            case 'text':\n            default:\n                data = await response.text();\n        }\n        // Convert fetch headers to Capacitor HttpHeaders\n        const headers = {};\n        response.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            data,\n            headers,\n            status: response.status,\n            url: response.url,\n        };\n    }\n    /**\n     * Perform an Http GET request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async get(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n    }\n    /**\n     * Perform an Http POST request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async post(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n    }\n    /**\n     * Perform an Http PUT request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async put(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n    }\n    /**\n     * Perform an Http PATCH request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async patch(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n    }\n    /**\n     * Perform an Http DELETE request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async delete(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n    }\n}\nconst CapacitorHttp = registerPlugin('CapacitorHttp', {\n    web: () => new CapacitorHttpPluginWeb(),\n});\n/******** END HTTP PLUGIN ********/\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXLGlDQUFpQyxTQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsR0FBRyxLQUFLLDRCQUE0QixTQUFTO0FBQ2pIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0IsS0FBSyxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVSxnREFBZ0QsR0FBRyxpQkFBaUI7QUFDN0cscUVBQXFFO0FBQ3JFLHFGQUFxRixZQUFZO0FBQ2pHLGlDQUFpQyxXQUFXLEdBQUcsbUJBQW1CLEVBQUUsVUFBVSxPQUFPLE9BQU8sRUFBRSxRQUFRO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVksR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDhFQUE4RSxVQUFVLDBCQUEwQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUksR0FBRyxhQUFhO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxhQUFhO0FBQzFDO0FBQ0Esa0JBQWtCLFlBQVksR0FBRyxLQUFLO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLG1DQUFtQywyREFBMkQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSxHQUFHLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFK0k7QUFDL0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maW5hbmNpYWwtZGFzaGJvYXJkLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2NvcmUvZGlzdC9pbmRleC5qcz8xNWQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBDYXBhY2l0b3I6IGh0dHBzOi8vY2FwYWNpdG9yanMuY29tLyAtIE1JVCBMaWNlbnNlICovXG52YXIgRXhjZXB0aW9uQ29kZTtcbihmdW5jdGlvbiAoRXhjZXB0aW9uQ29kZSkge1xuICAgIC8qKlxuICAgICAqIEFQSSBpcyBub3QgaW1wbGVtZW50ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHVzdWFsbHkgbWVhbnMgdGhlIEFQSSBjYW4ndCBiZSB1c2VkIGJlY2F1c2UgaXQgaXMgbm90IGltcGxlbWVudGVkIGZvclxuICAgICAqIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqL1xuICAgIEV4Y2VwdGlvbkNvZGVbXCJVbmltcGxlbWVudGVkXCJdID0gXCJVTklNUExFTUVOVEVEXCI7XG4gICAgLyoqXG4gICAgICogQVBJIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1lYW5zIHRoZSBBUEkgY2FuJ3QgYmUgdXNlZCByaWdodCBub3cgYmVjYXVzZTpcbiAgICAgKiAgIC0gaXQgaXMgY3VycmVudGx5IG1pc3NpbmcgYSBwcmVyZXF1aXNpdGUsIHN1Y2ggYXMgbmV0d29yayBjb25uZWN0aXZpdHlcbiAgICAgKiAgIC0gaXQgcmVxdWlyZXMgYSBwYXJ0aWN1bGFyIHBsYXRmb3JtIG9yIGJyb3dzZXIgdmVyc2lvblxuICAgICAqL1xuICAgIEV4Y2VwdGlvbkNvZGVbXCJVbmF2YWlsYWJsZVwiXSA9IFwiVU5BVkFJTEFCTEVcIjtcbn0pKEV4Y2VwdGlvbkNvZGUgfHwgKEV4Y2VwdGlvbkNvZGUgPSB7fSkpO1xuY2xhc3MgQ2FwYWNpdG9yRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuY29uc3QgZ2V0UGxhdGZvcm1JZCA9ICh3aW4pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uYW5kcm9pZEJyaWRnZSkge1xuICAgICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICgoX2IgPSAoX2EgPSB3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4ud2Via2l0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZUhhbmRsZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnd2ViJztcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVDYXBhY2l0b3IgPSAod2luKSA9PiB7XG4gICAgY29uc3QgY2FwQ3VzdG9tUGxhdGZvcm0gPSB3aW4uQ2FwYWNpdG9yQ3VzdG9tUGxhdGZvcm0gfHwgbnVsbDtcbiAgICBjb25zdCBjYXAgPSB3aW4uQ2FwYWNpdG9yIHx8IHt9O1xuICAgIGNvbnN0IFBsdWdpbnMgPSAoY2FwLlBsdWdpbnMgPSBjYXAuUGx1Z2lucyB8fCB7fSk7XG4gICAgY29uc3QgZ2V0UGxhdGZvcm0gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYXBDdXN0b21QbGF0Zm9ybSAhPT0gbnVsbCA/IGNhcEN1c3RvbVBsYXRmb3JtLm5hbWUgOiBnZXRQbGF0Zm9ybUlkKHdpbik7XG4gICAgfTtcbiAgICBjb25zdCBpc05hdGl2ZVBsYXRmb3JtID0gKCkgPT4gZ2V0UGxhdGZvcm0oKSAhPT0gJ3dlYic7XG4gICAgY29uc3QgaXNQbHVnaW5BdmFpbGFibGUgPSAocGx1Z2luTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSByZWdpc3RlcmVkUGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICAgIGlmIChwbHVnaW4gPT09IG51bGwgfHwgcGx1Z2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW4ucGxhdGZvcm1zLmhhcyhnZXRQbGF0Zm9ybSgpKSkge1xuICAgICAgICAgICAgLy8gSlMgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQbHVnaW5IZWFkZXIocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIE5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQbHVnaW5IZWFkZXIgPSAocGx1Z2luTmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBjYXAuUGx1Z2luSGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKGgpID0+IGgubmFtZSA9PT0gcGx1Z2luTmFtZSk7IH07XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyKSA9PiB3aW4uY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRQbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJlZ2lzdGVyUGx1Z2luID0gKHBsdWdpbk5hbWUsIGpzSW1wbGVtZW50YXRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFBsdWdpbiA9IHJlZ2lzdGVyZWRQbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FwYWNpdG9yIHBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQuIENhbm5vdCByZWdpc3RlciBwbHVnaW5zIHR3aWNlLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRQbHVnaW4ucHJveHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBjb25zdCBwbHVnaW5IZWFkZXIgPSBnZXRQbHVnaW5IZWFkZXIocGx1Z2luTmFtZSk7XG4gICAgICAgIGxldCBqc0ltcGxlbWVudGF0aW9uO1xuICAgICAgICBjb25zdCBsb2FkUGx1Z2luSW1wbGVtZW50YXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWpzSW1wbGVtZW50YXRpb24gJiYgcGxhdGZvcm0gaW4ganNJbXBsZW1lbnRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBqc0ltcGxlbWVudGF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoanNJbXBsZW1lbnRhdGlvbiA9IGF3YWl0IGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoanNJbXBsZW1lbnRhdGlvbiA9IGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYXBDdXN0b21QbGF0Zm9ybSAhPT0gbnVsbCAmJiAhanNJbXBsZW1lbnRhdGlvbiAmJiAnd2ViJyBpbiBqc0ltcGxlbWVudGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGpzSW1wbGVtZW50YXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YganNJbXBsZW1lbnRhdGlvbnNbJ3dlYiddID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChqc0ltcGxlbWVudGF0aW9uID0gYXdhaXQganNJbXBsZW1lbnRhdGlvbnNbJ3dlYiddKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChqc0ltcGxlbWVudGF0aW9uID0ganNJbXBsZW1lbnRhdGlvbnNbJ3dlYiddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc0ltcGxlbWVudGF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjcmVhdGVQbHVnaW5NZXRob2QgPSAoaW1wbCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChwbHVnaW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRob2RIZWFkZXIgPSBwbHVnaW5IZWFkZXIgPT09IG51bGwgfHwgcGx1Z2luSGVhZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW5IZWFkZXIubWV0aG9kcy5maW5kKChtKSA9PiBwcm9wID09PSBtLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZEhlYWRlci5ydHlwZSA9PT0gJ3Byb21pc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMpID0+IGNhcC5uYXRpdmVQcm9taXNlKHBsdWdpbk5hbWUsIHByb3AudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiBjYXAubmF0aXZlQ2FsbGJhY2socGx1Z2luTmFtZSwgcHJvcC50b1N0cmluZygpLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gaW1wbFtwcm9wXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaW1wbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSBpbXBsW3Byb3BdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmluZChpbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDYXBhY2l0b3JFeGNlcHRpb24oYFwiJHtwbHVnaW5OYW1lfVwiIHBsdWdpbiBpcyBub3QgaW1wbGVtZW50ZWQgb24gJHtwbGF0Zm9ybX1gLCBFeGNlcHRpb25Db2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyID0gKHByb3ApID0+IHtcbiAgICAgICAgICAgIGxldCByZW1vdmU7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbG9hZFBsdWdpbkltcGxlbWVudGF0aW9uKCkudGhlbigoaW1wbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGNyZWF0ZVBsdWdpbk1ldGhvZChpbXBsLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gZm4oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBwID09PSBudWxsIHx8IHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHAucmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FwYWNpdG9yRXhjZXB0aW9uKGBcIiR7cGx1Z2luTmFtZX0uJHtwcm9wfSgpXCIgaXMgbm90IGltcGxlbWVudGVkIG9uICR7cGxhdGZvcm19YCwgRXhjZXB0aW9uQ29kZS5VbmltcGxlbWVudGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnYWRkTGlzdGVuZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucmVtb3ZlID0gYXN5bmMgKCkgPT4gcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNvbWUgZmxhaXIg4pyoXG4gICAgICAgICAgICB3cmFwcGVyLnRvU3RyaW5nID0gKCkgPT4gYCR7cHJvcC50b1N0cmluZygpfSgpIHsgW2NhcGFjaXRvciBjb2RlXSB9YDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyLCAnbmFtZScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZExpc3RlbmVyID0gY3JlYXRlUGx1Z2luTWV0aG9kV3JhcHBlcignYWRkTGlzdGVuZXInKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICBjb25zdCBhZGRMaXN0ZW5lck5hdGl2ZSA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gYWRkTGlzdGVuZXIoeyBldmVudE5hbWUgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBhd2FpdCBjYWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGNhbGwudGhlbigoKSA9PiByZXNvbHZlKHsgcmVtb3ZlIH0pKSk7XG4gICAgICAgICAgICBwLnJlbW92ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVzaW5nIGFkZExpc3RlbmVyKCkgd2l0aG91dCAnYXdhaXQnIGlzIGRlcHJlY2F0ZWQuYCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQoXywgcHJvcCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMDMwXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQkdHlwZW9mJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvSlNPTic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkTGlzdGVuZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkhlYWRlciA/IGFkZExpc3RlbmVyTmF0aXZlIDogYWRkTGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZUxpc3RlbmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBQbHVnaW5zW3BsdWdpbk5hbWVdID0gcHJveHk7XG4gICAgICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnNldChwbHVnaW5OYW1lLCB7XG4gICAgICAgICAgICBuYW1lOiBwbHVnaW5OYW1lLFxuICAgICAgICAgICAgcHJveHksXG4gICAgICAgICAgICBwbGF0Zm9ybXM6IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGpzSW1wbGVtZW50YXRpb25zKSwgLi4uKHBsdWdpbkhlYWRlciA/IFtwbGF0Zm9ybV0gOiBbXSldKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9O1xuICAgIC8vIEFkZCBpbiBjb252ZXJ0RmlsZVNyYyBmb3Igd2ViLCBpdCB3aWxsIGFscmVhZHkgYmUgYXZhaWxhYmxlIGluIG5hdGl2ZSBjb250ZXh0XG4gICAgaWYgKCFjYXAuY29udmVydEZpbGVTcmMpIHtcbiAgICAgICAgY2FwLmNvbnZlcnRGaWxlU3JjID0gKGZpbGVQYXRoKSA9PiBmaWxlUGF0aDtcbiAgICB9XG4gICAgY2FwLmdldFBsYXRmb3JtID0gZ2V0UGxhdGZvcm07XG4gICAgY2FwLmhhbmRsZUVycm9yID0gaGFuZGxlRXJyb3I7XG4gICAgY2FwLmlzTmF0aXZlUGxhdGZvcm0gPSBpc05hdGl2ZVBsYXRmb3JtO1xuICAgIGNhcC5pc1BsdWdpbkF2YWlsYWJsZSA9IGlzUGx1Z2luQXZhaWxhYmxlO1xuICAgIGNhcC5yZWdpc3RlclBsdWdpbiA9IHJlZ2lzdGVyUGx1Z2luO1xuICAgIGNhcC5FeGNlcHRpb24gPSBDYXBhY2l0b3JFeGNlcHRpb247XG4gICAgY2FwLkRFQlVHID0gISFjYXAuREVCVUc7XG4gICAgY2FwLmlzTG9nZ2luZ0VuYWJsZWQgPSAhIWNhcC5pc0xvZ2dpbmdFbmFibGVkO1xuICAgIHJldHVybiBjYXA7XG59O1xuY29uc3QgaW5pdENhcGFjaXRvckdsb2JhbCA9ICh3aW4pID0+ICh3aW4uQ2FwYWNpdG9yID0gY3JlYXRlQ2FwYWNpdG9yKHdpbikpO1xuXG5jb25zdCBDYXBhY2l0b3IgPSAvKiNfX1BVUkVfXyovIGluaXRDYXBhY2l0b3JHbG9iYWwodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgPyBnbG9iYWxUaGlzXG4gICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgICA6IHt9KTtcbmNvbnN0IHJlZ2lzdGVyUGx1Z2luID0gQ2FwYWNpdG9yLnJlZ2lzdGVyUGx1Z2luO1xuXG4vKipcbiAqIEJhc2UgY2xhc3Mgd2ViIHBsdWdpbnMgc2hvdWxkIGV4dGVuZC5cbiAqL1xuY2xhc3MgV2ViUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5yZXRhaW5lZEV2ZW50QXJndW1lbnRzID0ge307XG4gICAgICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGdW5jKSB7XG4gICAgICAgIGxldCBmaXJzdExpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICAgICAgICBmaXJzdExpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXJGdW5jKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBhZGRlZCBhIHdpbmRvdyBsaXN0ZW5lciBmb3IgdGhpcyBldmVudCBhbmQgaXQgcmVxdWlyZXMgb25lLFxuICAgICAgICAvLyBnbyBhaGVhZCBhbmQgYWRkIGl0XG4gICAgICAgIGNvbnN0IHdpbmRvd0xpc3RlbmVyID0gdGhpcy53aW5kb3dMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKHdpbmRvd0xpc3RlbmVyICYmICF3aW5kb3dMaXN0ZW5lci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVyKHdpbmRvd0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5zZW5kUmV0YWluZWRBcmd1bWVudHNGb3JFdmVudChldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IGFzeW5jICgpID0+IHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lckZ1bmMpO1xuICAgICAgICBjb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKHsgcmVtb3ZlIH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIGluIHRoaXMud2luZG93TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVyKHRoaXMud2luZG93TGlzdGVuZXJzW2xpc3RlbmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgbm90aWZ5TGlzdGVuZXJzKGV2ZW50TmFtZSwgZGF0YSwgcmV0YWluVW50aWxDb25zdW1lZCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKHJldGFpblVudGlsQ29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJncyA9IHRoaXMucmV0YWluZWRFdmVudEFyZ3VtZW50c1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldGFpbmVkRXZlbnRBcmd1bWVudHNbZXZlbnROYW1lXSA9IGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihkYXRhKSk7XG4gICAgfVxuICAgIGhhc0xpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gISEoKF9hID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyV2luZG93TGlzdGVuZXIod2luZG93RXZlbnROYW1lLCBwbHVnaW5FdmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy53aW5kb3dMaXN0ZW5lcnNbcGx1Z2luRXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgd2luZG93RXZlbnROYW1lLFxuICAgICAgICAgICAgcGx1Z2luRXZlbnROYW1lLFxuICAgICAgICAgICAgaGFuZGxlcjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMocGx1Z2luRXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB1bmltcGxlbWVudGVkKG1zZyA9ICdub3QgaW1wbGVtZW50ZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FwYWNpdG9yLkV4Y2VwdGlvbihtc2csIEV4Y2VwdGlvbkNvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgfVxuICAgIHVuYXZhaWxhYmxlKG1zZyA9ICdub3QgYXZhaWxhYmxlJykge1xuICAgICAgICByZXR1cm4gbmV3IENhcGFjaXRvci5FeGNlcHRpb24obXNnLCBFeGNlcHRpb25Db2RlLlVuYXZhaWxhYmxlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lckZ1bmMpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyRnVuYyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGZvciB0aGlzIHR5cGUgb2YgZXZlbnQsXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2luZG93IGxpc3RlbmVyXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXIodGhpcy53aW5kb3dMaXN0ZW5lcnNbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXIoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGhhbmRsZS53aW5kb3dFdmVudE5hbWUsIGhhbmRsZS5oYW5kbGVyKTtcbiAgICAgICAgaGFuZGxlLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcihoYW5kbGUpIHtcbiAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGUud2luZG93RXZlbnROYW1lLCBoYW5kbGUuaGFuZGxlcik7XG4gICAgICAgIGhhbmRsZS5yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNlbmRSZXRhaW5lZEFyZ3VtZW50c0ZvckV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5yZXRhaW5lZEV2ZW50QXJndW1lbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJldGFpbmVkRXZlbnRBcmd1bWVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgYXJncy5mb3JFYWNoKChhcmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGV2ZW50TmFtZSwgYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBXZWJWaWV3ID0gLyojX19QVVJFX18qLyByZWdpc3RlclBsdWdpbignV2ViVmlldycpO1xuLyoqKioqKioqIEVORCBXRUIgVklFVyBQTFVHSU4gKioqKioqKiovXG4vKioqKioqKiogQ09PS0lFUyBQTFVHSU4gKioqKioqKiovXG4vKipcbiAqIFNhZmVseSB3ZWIgZW5jb2RlIGEgc3RyaW5nIHZhbHVlIChpbnNwaXJlZCBieSBqcy1jb29raWUpXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlXG4gKi9cbmNvbnN0IGVuY29kZSA9IChzdHIpID0+IGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gICAgLnJlcGxhY2UoLyUoMlszNDZCXXw1RXw2MHw3QykvZywgZGVjb2RlVVJJQ29tcG9uZW50KVxuICAgIC5yZXBsYWNlKC9bKCldL2csIGVzY2FwZSk7XG4vKipcbiAqIFNhZmVseSB3ZWIgZGVjb2RlIGEgc3RyaW5nIHZhbHVlIChpbnNwaXJlZCBieSBqcy1jb29raWUpXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdmFsdWUgdG8gZGVjb2RlXG4gKi9cbmNvbnN0IGRlY29kZSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oJVtcXGRBLUZdezJ9KSsvZ2ksIGRlY29kZVVSSUNvbXBvbmVudCk7XG5jbGFzcyBDYXBhY2l0b3JDb29raWVzUGx1Z2luV2ViIGV4dGVuZHMgV2ViUGx1Z2luIHtcbiAgICBhc3luYyBnZXRDb29raWVzKCkge1xuICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llO1xuICAgICAgICBjb25zdCBjb29raWVNYXAgPSB7fTtcbiAgICAgICAgY29va2llcy5zcGxpdCgnOycpLmZvckVhY2goKGNvb2tpZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvb2tpZS5sZW5ndGggPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGZpcnN0IFwiPVwiIHdpdGggQ0FQX0NPT0tJRSB0byBwcmV2ZW50IHNwbGl0dGluZyBvbiBhZGRpdGlvbmFsIFwiPVwiXG4gICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gY29va2llLnJlcGxhY2UoLz0vLCAnQ0FQX0NPT0tJRScpLnNwbGl0KCdDQVBfQ09PS0lFJyk7XG4gICAgICAgICAgICBrZXkgPSBkZWNvZGUoa2V5KS50cmltKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlY29kZSh2YWx1ZSkudHJpbSgpO1xuICAgICAgICAgICAgY29va2llTWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb29raWVNYXA7XG4gICAgfVxuICAgIGFzeW5jIHNldENvb2tpZShvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTYWZlbHkgRW5jb2RlZCBLZXkvVmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBlbmNvZGUob3B0aW9ucy5rZXkpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFZhbHVlID0gZW5jb2RlKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gJiBzYW5pdGl6ZSBvcHRpb25zXG4gICAgICAgICAgICBjb25zdCBleHBpcmVzID0gYDsgZXhwaXJlcz0keyhvcHRpb25zLmV4cGlyZXMgfHwgJycpLnJlcGxhY2UoJ2V4cGlyZXM9JywgJycpfWA7IC8vIERlZmF1bHQgaXMgXCI7IGV4cGlyZXM9XCJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8ICcvJykucmVwbGFjZSgncGF0aD0nLCAnJyk7IC8vIERlZmF1bHQgaXMgXCJwYXRoPS9cIlxuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3B0aW9ucy51cmwgIT0gbnVsbCAmJiBvcHRpb25zLnVybC5sZW5ndGggPiAwID8gYGRvbWFpbj0ke29wdGlvbnMudXJsfWAgOiAnJztcbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2VuY29kZWRLZXl9PSR7ZW5jb2RlZFZhbHVlIHx8ICcnfSR7ZXhwaXJlc307IHBhdGg9JHtwYXRofTsgJHtkb21haW59O2A7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUNvb2tpZShvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtvcHRpb25zLmtleX09OyBNYXgtQWdlPTBgO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGVhckNvb2tpZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykgfHwgW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLnJlcGxhY2UoL14gKy8sICcnKS5yZXBsYWNlKC89LiovLCBgPTtleHBpcmVzPSR7bmV3IERhdGUoKS50b1VUQ1N0cmluZygpfTtwYXRoPS9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xlYXJBbGxDb29raWVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhckNvb2tpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBDYXBhY2l0b3JDb29raWVzID0gcmVnaXN0ZXJQbHVnaW4oJ0NhcGFjaXRvckNvb2tpZXMnLCB7XG4gICAgd2ViOiAoKSA9PiBuZXcgQ2FwYWNpdG9yQ29va2llc1BsdWdpbldlYigpLFxufSk7XG4vLyBVVElMSVRZIEZVTkNUSU9OU1xuLyoqXG4gKiBSZWFkIGluIGEgQmxvYiB2YWx1ZSBhbmQgcmV0dXJuIGl0IGFzIGEgYmFzZTY0IHN0cmluZ1xuICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdmFsdWUgdG8gY29udmVydCB0byBhIGJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgcmVhZEJsb2JBc0Jhc2U2NCA9IGFzeW5jIChibG9iKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAvLyByZW1vdmUgcHJlZml4IFwiZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LFwiXG4gICAgICAgIHJlc29sdmUoYmFzZTY0U3RyaW5nLmluZGV4T2YoJywnKSA+PSAwID8gYmFzZTY0U3RyaW5nLnNwbGl0KCcsJylbMV0gOiBiYXNlNjRTdHJpbmcpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChlcnJvcik7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG59KTtcbi8qKlxuICogTm9ybWFsaXplIGFuIEh0dHBIZWFkZXJzIG1hcCBieSBsb3dlcmNhc2luZyBhbGwgb2YgdGhlIHZhbHVlc1xuICogQHBhcmFtIGhlYWRlcnMgVGhlIEh0dHBIZWFkZXJzIG9iamVjdCB0byBub3JtYWxpemVcbiAqL1xuY29uc3Qgbm9ybWFsaXplSHR0cEhlYWRlcnMgPSAoaGVhZGVycyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgY29uc3QgbG93ZXJlZEtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5tYXAoKGspID0+IGsudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGxvd2VyZWRLZXlzLnJlZHVjZSgoYWNjLCBrZXksIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gaGVhZGVyc1tvcmlnaW5hbEtleXNbaW5kZXhdXTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuLyoqXG4gKiBCdWlsZHMgYSBzdHJpbmcgb2YgdXJsIHBhcmFtZXRlcnMgdGhhdFxuICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiB1cmwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHNob3VsZEVuY29kZSB0cnVlIGlmIHlvdSBzaG91bGQgZW5jb2RlVVJJQ29tcG9uZW50KCkgdGhlIHZhbHVlcyAodHJ1ZSBieSBkZWZhdWx0KVxuICovXG5jb25zdCBidWlsZFVybFBhcmFtcyA9IChwYXJhbXMsIHNob3VsZEVuY29kZSA9IHRydWUpID0+IHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcbiAgICAgICAgbGV0IGVuY29kZWRWYWx1ZTtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaXRlbSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gc2hvdWxkRW5jb2RlID8gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikgOiBzdHI7XG4gICAgICAgICAgICAgICAgaXRlbSArPSBgJHtrZXl9PSR7ZW5jb2RlZFZhbHVlfSZgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBsYXN0IGNoYXJhY3RlciB3aWxsIGFsd2F5cyBiZSBcIiZcIiBzbyBzbGljZSBpdCBvZmZcbiAgICAgICAgICAgIGl0ZW0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gc2hvdWxkRW5jb2RlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgaXRlbSA9IGAke2tleX09JHtlbmNvZGVkVmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7YWNjdW11bGF0b3J9JiR7aXRlbX1gO1xuICAgIH0sICcnKTtcbiAgICAvLyBSZW1vdmUgaW5pdGlhbCBcIiZcIiBmcm9tIHRoZSByZWR1Y2VcbiAgICByZXR1cm4gb3V0cHV0LnN1YnN0cigxKTtcbn07XG4vKipcbiAqIEJ1aWxkIHRoZSBSZXF1ZXN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkIGludG8gdGhlIGluaXRpYWwgcmVxdWVzdFxuICogQHBhcmFtIG9wdGlvbnMgVGhlIEh0dHAgcGx1Z2luIG9wdGlvbnNcbiAqIEBwYXJhbSBleHRyYSBBbnkgZXh0cmEgUmVxdWVzdEluaXQgdmFsdWVzXG4gKi9cbmNvbnN0IGJ1aWxkUmVxdWVzdEluaXQgPSAob3B0aW9ucywgZXh0cmEgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfSwgZXh0cmEpO1xuICAgIC8vIEdldCB0aGUgY29udGVudC10eXBlXG4gICAgY29uc3QgaGVhZGVycyA9IG5vcm1hbGl6ZUh0dHBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgdHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIC8vIElmIGJvZHkgaXMgYWxyZWFkeSBhIHN0cmluZywgdGhlbiBwYXNzIGl0IHRocm91Z2ggYXMtaXMuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG91dHB1dC5ib2R5ID0gb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICAvLyBCdWlsZCByZXF1ZXN0IGluaXRpYWxpemVycyBiYXNlZCBvZmYgb2YgY29udGVudC10eXBlXG4gICAgZWxzZSBpZiAodHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLmRhdGEgfHwge30pKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ211bHRpcGFydC9mb3JtLWRhdGEnKSB8fCBvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgb3B0aW9ucy5kYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gZm9ybTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG91dHB1dC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtdHlwZScpOyAvLyBjb250ZW50LXR5cGUgd2lsbCBiZSBzZXQgYnkgYHdpbmRvdy5mZXRjaGAgdG8gaW5jbHVkeSBib3VuZGFyeVxuICAgICAgICBvdXRwdXQuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCB0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvdXRwdXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLy8gV0VCIElNUExFTUVOVEFUSU9OXG5jbGFzcyBDYXBhY2l0b3JIdHRwUGx1Z2luV2ViIGV4dGVuZHMgV2ViUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJbml0ID0gYnVpbGRSZXF1ZXN0SW5pdChvcHRpb25zLCBvcHRpb25zLndlYkZldGNoRXh0cmEpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBidWlsZFVybFBhcmFtcyhvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5zaG91bGRFbmNvZGVVcmxQYXJhbXMpO1xuICAgICAgICBjb25zdCB1cmwgPSB1cmxQYXJhbXMgPyBgJHtvcHRpb25zLnVybH0/JHt1cmxQYXJhbXN9YCA6IG9wdGlvbnMudXJsO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgcmVxdWVzdEluaXQpO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcbiAgICAgICAgLy8gRGVmYXVsdCB0byAndGV4dCcgcmVzcG9uc2VUeXBlIHNvIG5vIHBhcnNpbmcgaGFwcGVuc1xuICAgICAgICBsZXQgeyByZXNwb25zZVR5cGUgPSAndGV4dCcgfSA9IHJlc3BvbnNlLm9rID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICAvLyBJZiB0aGUgcmVzcG9uc2UgY29udGVudC10eXBlIGlzIGpzb24sIGZvcmNlIHRoZSByZXNwb25zZSB0byBiZSBqc29uXG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICByZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCBibG9iO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICAgICAgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVhZEJsb2JBc0Jhc2U2NChibG9iKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGZldGNoIGhlYWRlcnMgdG8gQ2FwYWNpdG9yIEh0dHBIZWFkZXJzXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSHR0cCBHRVQgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1ldGhvZDogJ0dFVCcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgUE9TVCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBwb3N0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1ldGhvZDogJ1BPU1QnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBIdHRwIFBVVCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBwdXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnUFVUJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSHR0cCBQQVRDSCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBwYXRjaChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdQQVRDSCcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgREVMRVRFIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdERUxFVEUnIH0pKTtcbiAgICB9XG59XG5jb25zdCBDYXBhY2l0b3JIdHRwID0gcmVnaXN0ZXJQbHVnaW4oJ0NhcGFjaXRvckh0dHAnLCB7XG4gICAgd2ViOiAoKSA9PiBuZXcgQ2FwYWNpdG9ySHR0cFBsdWdpbldlYigpLFxufSk7XG4vKioqKioqKiogRU5EIEhUVFAgUExVR0lOICoqKioqKioqL1xuXG5leHBvcnQgeyBDYXBhY2l0b3IsIENhcGFjaXRvckNvb2tpZXMsIENhcGFjaXRvckV4Y2VwdGlvbiwgQ2FwYWNpdG9ySHR0cCwgRXhjZXB0aW9uQ29kZSwgV2ViUGx1Z2luLCBXZWJWaWV3LCBidWlsZFJlcXVlc3RJbml0LCByZWdpc3RlclBsdWdpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/filesystem/dist/esm/definitions.js":
/*!********************************************************************!*\
  !*** ./node_modules/@capacitor/filesystem/dist/esm/definitions.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Directory: () => (/* binding */ Directory),\n/* harmony export */   Encoding: () => (/* binding */ Encoding),\n/* harmony export */   FilesystemDirectory: () => (/* binding */ FilesystemDirectory),\n/* harmony export */   FilesystemEncoding: () => (/* binding */ FilesystemEncoding)\n/* harmony export */ });\nvar Directory;\n(function (Directory) {\n    /**\n     * The Documents directory.\n     * On iOS it's the app's documents directory.\n     * Use this directory to store user-generated content.\n     * On Android it's the Public Documents folder, so it's accessible from other apps.\n     * It's not accessible on Android 10 unless the app enables legacy External Storage\n     * by adding `android:requestLegacyExternalStorage=\"true\"` in the `application` tag\n     * in the `AndroidManifest.xml`.\n     * On Android 11 or newer the app can only access the files/folders the app created.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"Documents\"] = \"DOCUMENTS\";\n    /**\n     * The Data directory.\n     * On iOS it will use the Documents directory.\n     * On Android it's the directory holding application files.\n     * Files will be deleted when the application is uninstalled.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"Data\"] = \"DATA\";\n    /**\n     * The Library directory.\n     * On iOS it will use the Library directory.\n     * On Android it's the directory holding application files.\n     * Files will be deleted when the application is uninstalled.\n     *\n     * @since 1.1.0\n     */\n    Directory[\"Library\"] = \"LIBRARY\";\n    /**\n     * The Cache directory.\n     * Can be deleted in cases of low memory, so use this directory to write app-specific files.\n     * that your app can re-create easily.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"Cache\"] = \"CACHE\";\n    /**\n     * The external directory.\n     * On iOS it will use the Documents directory.\n     * On Android it's the directory on the primary shared/external\n     * storage device where the application can place persistent files it owns.\n     * These files are internal to the applications, and not typically visible\n     * to the user as media.\n     * Files will be deleted when the application is uninstalled.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"External\"] = \"EXTERNAL\";\n    /**\n     * The external storage directory.\n     * On iOS it will use the Documents directory.\n     * On Android it's the primary shared/external storage directory.\n     * It's not accessible on Android 10 unless the app enables legacy External Storage\n     * by adding `android:requestLegacyExternalStorage=\"true\"` in the `application` tag\n     * in the `AndroidManifest.xml`.\n     * It's not accessible on Android 11 or newer.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"ExternalStorage\"] = \"EXTERNAL_STORAGE\";\n    /**\n     * The external cache directory.\n     * On iOS it will use the Documents directory.\n     * On Android it's the primary shared/external cache.\n     *\n     * @since 7.1.0\n     */\n    Directory[\"ExternalCache\"] = \"EXTERNAL_CACHE\";\n    /**\n     * The Library directory without cloud backup. Used in iOS.\n     * On Android it's the directory holding application files.\n     *\n     * @since 7.1.0\n     */\n    Directory[\"LibraryNoCloud\"] = \"LIBRARY_NO_CLOUD\";\n    /**\n     * A temporary directory for iOS.\n     * On Android it's the directory holding the application cache.\n     *\n     * @since 7.1.0\n     */\n    Directory[\"Temporary\"] = \"TEMPORARY\";\n})(Directory || (Directory = {}));\nvar Encoding;\n(function (Encoding) {\n    /**\n     * Eight-bit UCS Transformation Format\n     *\n     * @since 1.0.0\n     */\n    Encoding[\"UTF8\"] = \"utf8\";\n    /**\n     * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the\n     * Unicode character set\n     * This encoding is only supported on Android.\n     *\n     * @since 1.0.0\n     */\n    Encoding[\"ASCII\"] = \"ascii\";\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark\n     * This encoding is only supported on Android.\n     *\n     * @since 1.0.0\n     */\n    Encoding[\"UTF16\"] = \"utf16\";\n})(Encoding || (Encoding = {}));\n/**\n * @deprecated Use `Directory`.\n * @since 1.0.0\n */\nconst FilesystemDirectory = Directory;\n/**\n * @deprecated Use `Encoding`.\n * @since 1.0.0\n */\nconst FilesystemEncoding = Encoding;\n//# sourceMappingURL=definitions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9maWxlc3lzdGVtL2Rpc3QvZXNtL2RlZmluaXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUN4QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmluYW5jaWFsLWRhc2hib2FyZC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9maWxlc3lzdGVtL2Rpc3QvZXNtL2RlZmluaXRpb25zLmpzPzZmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBEaXJlY3Rvcnk7XG4oZnVuY3Rpb24gKERpcmVjdG9yeSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBEb2N1bWVudHMgZGlyZWN0b3J5LlxuICAgICAqIE9uIGlPUyBpdCdzIHRoZSBhcHAncyBkb2N1bWVudHMgZGlyZWN0b3J5LlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdG9yeSB0byBzdG9yZSB1c2VyLWdlbmVyYXRlZCBjb250ZW50LlxuICAgICAqIE9uIEFuZHJvaWQgaXQncyB0aGUgUHVibGljIERvY3VtZW50cyBmb2xkZXIsIHNvIGl0J3MgYWNjZXNzaWJsZSBmcm9tIG90aGVyIGFwcHMuXG4gICAgICogSXQncyBub3QgYWNjZXNzaWJsZSBvbiBBbmRyb2lkIDEwIHVubGVzcyB0aGUgYXBwIGVuYWJsZXMgbGVnYWN5IEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKiBieSBhZGRpbmcgYGFuZHJvaWQ6cmVxdWVzdExlZ2FjeUV4dGVybmFsU3RvcmFnZT1cInRydWVcImAgaW4gdGhlIGBhcHBsaWNhdGlvbmAgdGFnXG4gICAgICogaW4gdGhlIGBBbmRyb2lkTWFuaWZlc3QueG1sYC5cbiAgICAgKiBPbiBBbmRyb2lkIDExIG9yIG5ld2VyIHRoZSBhcHAgY2FuIG9ubHkgYWNjZXNzIHRoZSBmaWxlcy9mb2xkZXJzIHRoZSBhcHAgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgIERpcmVjdG9yeVtcIkRvY3VtZW50c1wiXSA9IFwiRE9DVU1FTlRTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIERhdGEgZGlyZWN0b3J5LlxuICAgICAqIE9uIGlPUyBpdCB3aWxsIHVzZSB0aGUgRG9jdW1lbnRzIGRpcmVjdG9yeS5cbiAgICAgKiBPbiBBbmRyb2lkIGl0J3MgdGhlIGRpcmVjdG9yeSBob2xkaW5nIGFwcGxpY2F0aW9uIGZpbGVzLlxuICAgICAqIEZpbGVzIHdpbGwgYmUgZGVsZXRlZCB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyB1bmluc3RhbGxlZC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgIERpcmVjdG9yeVtcIkRhdGFcIl0gPSBcIkRBVEFcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgTGlicmFyeSBkaXJlY3RvcnkuXG4gICAgICogT24gaU9TIGl0IHdpbGwgdXNlIHRoZSBMaWJyYXJ5IGRpcmVjdG9yeS5cbiAgICAgKiBPbiBBbmRyb2lkIGl0J3MgdGhlIGRpcmVjdG9yeSBob2xkaW5nIGFwcGxpY2F0aW9uIGZpbGVzLlxuICAgICAqIEZpbGVzIHdpbGwgYmUgZGVsZXRlZCB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyB1bmluc3RhbGxlZC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqL1xuICAgIERpcmVjdG9yeVtcIkxpYnJhcnlcIl0gPSBcIkxJQlJBUllcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgQ2FjaGUgZGlyZWN0b3J5LlxuICAgICAqIENhbiBiZSBkZWxldGVkIGluIGNhc2VzIG9mIGxvdyBtZW1vcnksIHNvIHVzZSB0aGlzIGRpcmVjdG9yeSB0byB3cml0ZSBhcHAtc3BlY2lmaWMgZmlsZXMuXG4gICAgICogdGhhdCB5b3VyIGFwcCBjYW4gcmUtY3JlYXRlIGVhc2lseS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqL1xuICAgIERpcmVjdG9yeVtcIkNhY2hlXCJdID0gXCJDQUNIRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBleHRlcm5hbCBkaXJlY3RvcnkuXG4gICAgICogT24gaU9TIGl0IHdpbGwgdXNlIHRoZSBEb2N1bWVudHMgZGlyZWN0b3J5LlxuICAgICAqIE9uIEFuZHJvaWQgaXQncyB0aGUgZGlyZWN0b3J5IG9uIHRoZSBwcmltYXJ5IHNoYXJlZC9leHRlcm5hbFxuICAgICAqIHN0b3JhZ2UgZGV2aWNlIHdoZXJlIHRoZSBhcHBsaWNhdGlvbiBjYW4gcGxhY2UgcGVyc2lzdGVudCBmaWxlcyBpdCBvd25zLlxuICAgICAqIFRoZXNlIGZpbGVzIGFyZSBpbnRlcm5hbCB0byB0aGUgYXBwbGljYXRpb25zLCBhbmQgbm90IHR5cGljYWxseSB2aXNpYmxlXG4gICAgICogdG8gdGhlIHVzZXIgYXMgbWVkaWEuXG4gICAgICogRmlsZXMgd2lsbCBiZSBkZWxldGVkIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHVuaW5zdGFsbGVkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICovXG4gICAgRGlyZWN0b3J5W1wiRXh0ZXJuYWxcIl0gPSBcIkVYVEVSTkFMXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVybmFsIHN0b3JhZ2UgZGlyZWN0b3J5LlxuICAgICAqIE9uIGlPUyBpdCB3aWxsIHVzZSB0aGUgRG9jdW1lbnRzIGRpcmVjdG9yeS5cbiAgICAgKiBPbiBBbmRyb2lkIGl0J3MgdGhlIHByaW1hcnkgc2hhcmVkL2V4dGVybmFsIHN0b3JhZ2UgZGlyZWN0b3J5LlxuICAgICAqIEl0J3Mgbm90IGFjY2Vzc2libGUgb24gQW5kcm9pZCAxMCB1bmxlc3MgdGhlIGFwcCBlbmFibGVzIGxlZ2FjeSBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICogYnkgYWRkaW5nIGBhbmRyb2lkOnJlcXVlc3RMZWdhY3lFeHRlcm5hbFN0b3JhZ2U9XCJ0cnVlXCJgIGluIHRoZSBgYXBwbGljYXRpb25gIHRhZ1xuICAgICAqIGluIHRoZSBgQW5kcm9pZE1hbmlmZXN0LnhtbGAuXG4gICAgICogSXQncyBub3QgYWNjZXNzaWJsZSBvbiBBbmRyb2lkIDExIG9yIG5ld2VyLlxuICAgICAqXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICovXG4gICAgRGlyZWN0b3J5W1wiRXh0ZXJuYWxTdG9yYWdlXCJdID0gXCJFWFRFUk5BTF9TVE9SQUdFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVybmFsIGNhY2hlIGRpcmVjdG9yeS5cbiAgICAgKiBPbiBpT1MgaXQgd2lsbCB1c2UgdGhlIERvY3VtZW50cyBkaXJlY3RvcnkuXG4gICAgICogT24gQW5kcm9pZCBpdCdzIHRoZSBwcmltYXJ5IHNoYXJlZC9leHRlcm5hbCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSA3LjEuMFxuICAgICAqL1xuICAgIERpcmVjdG9yeVtcIkV4dGVybmFsQ2FjaGVcIl0gPSBcIkVYVEVSTkFMX0NBQ0hFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIExpYnJhcnkgZGlyZWN0b3J5IHdpdGhvdXQgY2xvdWQgYmFja3VwLiBVc2VkIGluIGlPUy5cbiAgICAgKiBPbiBBbmRyb2lkIGl0J3MgdGhlIGRpcmVjdG9yeSBob2xkaW5nIGFwcGxpY2F0aW9uIGZpbGVzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDcuMS4wXG4gICAgICovXG4gICAgRGlyZWN0b3J5W1wiTGlicmFyeU5vQ2xvdWRcIl0gPSBcIkxJQlJBUllfTk9fQ0xPVURcIjtcbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSBkaXJlY3RvcnkgZm9yIGlPUy5cbiAgICAgKiBPbiBBbmRyb2lkIGl0J3MgdGhlIGRpcmVjdG9yeSBob2xkaW5nIHRoZSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSA3LjEuMFxuICAgICAqL1xuICAgIERpcmVjdG9yeVtcIlRlbXBvcmFyeVwiXSA9IFwiVEVNUE9SQVJZXCI7XG59KShEaXJlY3RvcnkgfHwgKERpcmVjdG9yeSA9IHt9KSk7XG5leHBvcnQgdmFyIEVuY29kaW5nO1xuKGZ1bmN0aW9uIChFbmNvZGluZykge1xuICAgIC8qKlxuICAgICAqIEVpZ2h0LWJpdCBVQ1MgVHJhbnNmb3JtYXRpb24gRm9ybWF0XG4gICAgICpcbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKi9cbiAgICBFbmNvZGluZ1tcIlVURjhcIl0gPSBcInV0ZjhcIjtcbiAgICAvKipcbiAgICAgKiBTZXZlbi1iaXQgQVNDSUksIGEuay5hLiBJU082NDYtVVMsIGEuay5hLiB0aGUgQmFzaWMgTGF0aW4gYmxvY2sgb2YgdGhlXG4gICAgICogVW5pY29kZSBjaGFyYWN0ZXIgc2V0XG4gICAgICogVGhpcyBlbmNvZGluZyBpcyBvbmx5IHN1cHBvcnRlZCBvbiBBbmRyb2lkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICovXG4gICAgRW5jb2RpbmdbXCJBU0NJSVwiXSA9IFwiYXNjaWlcIjtcbiAgICAvKipcbiAgICAgKiBTaXh0ZWVuLWJpdCBVQ1MgVHJhbnNmb3JtYXRpb24gRm9ybWF0LCBieXRlIG9yZGVyIGlkZW50aWZpZWQgYnkgYW5cbiAgICAgKiBvcHRpb25hbCBieXRlLW9yZGVyIG1hcmtcbiAgICAgKiBUaGlzIGVuY29kaW5nIGlzIG9ubHkgc3VwcG9ydGVkIG9uIEFuZHJvaWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKi9cbiAgICBFbmNvZGluZ1tcIlVURjE2XCJdID0gXCJ1dGYxNlwiO1xufSkoRW5jb2RpbmcgfHwgKEVuY29kaW5nID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBEaXJlY3RvcnlgLlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBGaWxlc3lzdGVtRGlyZWN0b3J5ID0gRGlyZWN0b3J5O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYEVuY29kaW5nYC5cbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgY29uc3QgRmlsZXN5c3RlbUVuY29kaW5nID0gRW5jb2Rpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZpbml0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/filesystem/dist/esm/definitions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/filesystem/dist/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@capacitor/filesystem/dist/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Directory: () => (/* reexport safe */ _definitions__WEBPACK_IMPORTED_MODULE_2__.Directory),\n/* harmony export */   Encoding: () => (/* reexport safe */ _definitions__WEBPACK_IMPORTED_MODULE_2__.Encoding),\n/* harmony export */   Filesystem: () => (/* binding */ Filesystem),\n/* harmony export */   FilesystemDirectory: () => (/* reexport safe */ _definitions__WEBPACK_IMPORTED_MODULE_2__.FilesystemDirectory),\n/* harmony export */   FilesystemEncoding: () => (/* reexport safe */ _definitions__WEBPACK_IMPORTED_MODULE_2__.FilesystemEncoding)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @capacitor/core */ \"(ssr)/./node_modules/@capacitor/core/dist/index.js\");\n/* harmony import */ var _capacitor_synapse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @capacitor/synapse */ \"(ssr)/./node_modules/@capacitor/synapse/dist/synapse.mjs\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions */ \"(ssr)/./node_modules/@capacitor/filesystem/dist/esm/definitions.js\");\n\n\nconst Filesystem = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__.registerPlugin)('Filesystem', {\n    web: () => __webpack_require__.e(/*! import() */ \"vendor-chunks/@capacitor\").then(__webpack_require__.bind(__webpack_require__, /*! ./web */ \"(ssr)/./node_modules/@capacitor/filesystem/dist/esm/web.js\")).then((m) => new m.FilesystemWeb()),\n});\n(0,_capacitor_synapse__WEBPACK_IMPORTED_MODULE_1__.exposeSynapse)();\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9maWxlc3lzdGVtL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ0U7QUFDbkQsbUJBQW1CLCtEQUFjO0FBQ2pDLGVBQWUsZ01BQWU7QUFDOUIsQ0FBQztBQUNELGlFQUFhO0FBQ2lCO0FBQ1I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maW5hbmNpYWwtZGFzaGJvYXJkLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2ZpbGVzeXN0ZW0vZGlzdC9lc20vaW5kZXguanM/MTViMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlclBsdWdpbiB9IGZyb20gJ0BjYXBhY2l0b3IvY29yZSc7XG5pbXBvcnQgeyBleHBvc2VTeW5hcHNlIH0gZnJvbSAnQGNhcGFjaXRvci9zeW5hcHNlJztcbmNvbnN0IEZpbGVzeXN0ZW0gPSByZWdpc3RlclBsdWdpbignRmlsZXN5c3RlbScsIHtcbiAgICB3ZWI6ICgpID0+IGltcG9ydCgnLi93ZWInKS50aGVuKChtKSA9PiBuZXcgbS5GaWxlc3lzdGVtV2ViKCkpLFxufSk7XG5leHBvc2VTeW5hcHNlKCk7XG5leHBvcnQgKiBmcm9tICcuL2RlZmluaXRpb25zJztcbmV4cG9ydCB7IEZpbGVzeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/filesystem/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/filesystem/dist/esm/web.js":
/*!************************************************************!*\
  !*** ./node_modules/@capacitor/filesystem/dist/esm/web.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilesystemWeb: () => (/* binding */ FilesystemWeb)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @capacitor/core */ \"(ssr)/./node_modules/@capacitor/core/dist/index.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions */ \"(ssr)/./node_modules/@capacitor/filesystem/dist/esm/definitions.js\");\n\n\nfunction resolve(path) {\n    const posix = path.split('/').filter((item) => item !== '.');\n    const newPosix = [];\n    posix.forEach((item) => {\n        if (item === '..' && newPosix.length > 0 && newPosix[newPosix.length - 1] !== '..') {\n            newPosix.pop();\n        }\n        else {\n            newPosix.push(item);\n        }\n    });\n    return newPosix.join('/');\n}\nfunction isPathParent(parent, children) {\n    parent = resolve(parent);\n    children = resolve(children);\n    const pathsA = parent.split('/');\n    const pathsB = children.split('/');\n    return parent !== children && pathsA.every((value, index) => value === pathsB[index]);\n}\nclass FilesystemWeb extends _capacitor_core__WEBPACK_IMPORTED_MODULE_0__.WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.DB_VERSION = 1;\n        this.DB_NAME = 'Disc';\n        this._writeCmds = ['add', 'put', 'delete'];\n        /**\n         * Function that performs a http request to a server and downloads the file to the specified destination\n         *\n         * @deprecated Use the @capacitor/file-transfer plugin instead.\n         * @param options the options for the download operation\n         * @returns a promise that resolves with the download file result\n         */\n        this.downloadFile = async (options) => {\n            var _a, _b;\n            const requestInit = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__.buildRequestInit)(options, options.webFetchExtra);\n            const response = await fetch(options.url, requestInit);\n            let blob;\n            if (!options.progress)\n                blob = await response.blob();\n            else if (!(response === null || response === void 0 ? void 0 : response.body))\n                blob = new Blob();\n            else {\n                const reader = response.body.getReader();\n                let bytes = 0;\n                const chunks = [];\n                const contentType = response.headers.get('content-type');\n                const contentLength = parseInt(response.headers.get('content-length') || '0', 10);\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done)\n                        break;\n                    chunks.push(value);\n                    bytes += (value === null || value === void 0 ? void 0 : value.length) || 0;\n                    const status = {\n                        url: options.url,\n                        bytes,\n                        contentLength,\n                    };\n                    this.notifyListeners('progress', status);\n                }\n                const allChunks = new Uint8Array(bytes);\n                let position = 0;\n                for (const chunk of chunks) {\n                    if (typeof chunk === 'undefined')\n                        continue;\n                    allChunks.set(chunk, position);\n                    position += chunk.length;\n                }\n                blob = new Blob([allChunks.buffer], { type: contentType || undefined });\n            }\n            const result = await this.writeFile({\n                path: options.path,\n                directory: (_a = options.directory) !== null && _a !== void 0 ? _a : undefined,\n                recursive: (_b = options.recursive) !== null && _b !== void 0 ? _b : false,\n                data: blob,\n            });\n            return { path: result.uri, blob };\n        };\n    }\n    readFileInChunks(_options, _callback) {\n        throw this.unavailable('Method not implemented.');\n    }\n    async initDb() {\n        if (this._db !== undefined) {\n            return this._db;\n        }\n        if (!('indexedDB' in window)) {\n            throw this.unavailable(\"This browser doesn't support IndexedDB\");\n        }\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n            request.onupgradeneeded = FilesystemWeb.doUpgrade;\n            request.onsuccess = () => {\n                this._db = request.result;\n                resolve(request.result);\n            };\n            request.onerror = () => reject(request.error);\n            request.onblocked = () => {\n                console.warn('db blocked');\n            };\n        });\n    }\n    static doUpgrade(event) {\n        const eventTarget = event.target;\n        const db = eventTarget.result;\n        switch (event.oldVersion) {\n            case 0:\n            case 1:\n            default: {\n                if (db.objectStoreNames.contains('FileStorage')) {\n                    db.deleteObjectStore('FileStorage');\n                }\n                const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n                store.createIndex('by_folder', 'folder');\n            }\n        }\n    }\n    async dbRequest(cmd, args) {\n        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return this.initDb().then((conn) => {\n            return new Promise((resolve, reject) => {\n                const tx = conn.transaction(['FileStorage'], readFlag);\n                const store = tx.objectStore('FileStorage');\n                const req = store[cmd](...args);\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        });\n    }\n    async dbIndexRequest(indexName, cmd, args) {\n        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return this.initDb().then((conn) => {\n            return new Promise((resolve, reject) => {\n                const tx = conn.transaction(['FileStorage'], readFlag);\n                const store = tx.objectStore('FileStorage');\n                const index = store.index(indexName);\n                const req = index[cmd](...args);\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        });\n    }\n    getPath(directory, uriPath) {\n        const cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n        let fsPath = '';\n        if (directory !== undefined)\n            fsPath += '/' + directory;\n        if (uriPath !== '')\n            fsPath += '/' + cleanedUriPath;\n        return fsPath;\n    }\n    async clear() {\n        const conn = await this.initDb();\n        const tx = conn.transaction(['FileStorage'], 'readwrite');\n        const store = tx.objectStore('FileStorage');\n        store.clear();\n    }\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n    async readFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        // const encoding = options.encoding;\n        const entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined)\n            throw Error('File does not exist.');\n        return { data: entry.content ? entry.content : '' };\n    }\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n    async writeFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        let data = options.data;\n        const encoding = options.encoding;\n        const doRecursive = options.recursive;\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (occupiedEntry && occupiedEntry.type === 'directory')\n            throw Error('The supplied path is a directory.');\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        if (parentEntry === undefined) {\n            const subDirIndex = parentPath.indexOf('/', 1);\n            if (subDirIndex !== -1) {\n                const parentArgPath = parentPath.substr(subDirIndex);\n                await this.mkdir({\n                    path: parentArgPath,\n                    directory: options.directory,\n                    recursive: doRecursive,\n                });\n            }\n        }\n        if (!encoding && !(data instanceof Blob)) {\n            data = data.indexOf(',') >= 0 ? data.split(',')[1] : data;\n            if (!this.isBase64String(data))\n                throw Error('The supplied data is not valid base64 content.');\n        }\n        const now = Date.now();\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'file',\n            size: data instanceof Blob ? data.size : data.length,\n            ctime: now,\n            mtime: now,\n            content: data,\n        };\n        await this.dbRequest('put', [pathObj]);\n        return {\n            uri: pathObj.path,\n        };\n    }\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n    async appendFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        let data = options.data;\n        const encoding = options.encoding;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const now = Date.now();\n        let ctime = now;\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (occupiedEntry && occupiedEntry.type === 'directory')\n            throw Error('The supplied path is a directory.');\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        if (parentEntry === undefined) {\n            const subDirIndex = parentPath.indexOf('/', 1);\n            if (subDirIndex !== -1) {\n                const parentArgPath = parentPath.substr(subDirIndex);\n                await this.mkdir({\n                    path: parentArgPath,\n                    directory: options.directory,\n                    recursive: true,\n                });\n            }\n        }\n        if (!encoding && !this.isBase64String(data))\n            throw Error('The supplied data is not valid base64 content.');\n        if (occupiedEntry !== undefined) {\n            if (occupiedEntry.content instanceof Blob) {\n                throw Error('The occupied entry contains a Blob object which cannot be appended to.');\n            }\n            if (occupiedEntry.content !== undefined && !encoding) {\n                data = btoa(atob(occupiedEntry.content) + atob(data));\n            }\n            else {\n                data = occupiedEntry.content + data;\n            }\n            ctime = occupiedEntry.ctime;\n        }\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'file',\n            size: data.length,\n            ctime: ctime,\n            mtime: now,\n            content: data,\n        };\n        await this.dbRequest('put', [pathObj]);\n    }\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n    async deleteFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        const entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined)\n            throw Error('File does not exist.');\n        const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n        if (entries.length !== 0)\n            throw Error('Folder is not empty.');\n        await this.dbRequest('delete', [path]);\n    }\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n    async mkdir(options) {\n        const path = this.getPath(options.directory, options.path);\n        const doRecursive = options.recursive;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const depth = (path.match(/\\//g) || []).length;\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (depth === 1)\n            throw Error('Cannot create Root directory');\n        if (occupiedEntry !== undefined)\n            throw Error('Current directory does already exist.');\n        if (!doRecursive && depth !== 2 && parentEntry === undefined)\n            throw Error('Parent directory must exist');\n        if (doRecursive && depth !== 2 && parentEntry === undefined) {\n            const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n            await this.mkdir({\n                path: parentArgPath,\n                directory: options.directory,\n                recursive: doRecursive,\n            });\n        }\n        const now = Date.now();\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'directory',\n            size: 0,\n            ctime: now,\n            mtime: now,\n        };\n        await this.dbRequest('put', [pathObj]);\n    }\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n    async rmdir(options) {\n        const { path, directory, recursive } = options;\n        const fullPath = this.getPath(directory, path);\n        const entry = (await this.dbRequest('get', [fullPath]));\n        if (entry === undefined)\n            throw Error('Folder does not exist.');\n        if (entry.type !== 'directory')\n            throw Error('Requested path is not a directory');\n        const readDirResult = await this.readdir({ path, directory });\n        if (readDirResult.files.length !== 0 && !recursive)\n            throw Error('Folder is not empty');\n        for (const entry of readDirResult.files) {\n            const entryPath = `${path}/${entry.name}`;\n            const entryObj = await this.stat({ path: entryPath, directory });\n            if (entryObj.type === 'file') {\n                await this.deleteFile({ path: entryPath, directory });\n            }\n            else {\n                await this.rmdir({ path: entryPath, directory, recursive });\n            }\n        }\n        await this.dbRequest('delete', [fullPath]);\n    }\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n    async readdir(options) {\n        const path = this.getPath(options.directory, options.path);\n        const entry = (await this.dbRequest('get', [path]));\n        if (options.path !== '' && entry === undefined)\n            throw Error('Folder does not exist.');\n        const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n        const files = await Promise.all(entries.map(async (e) => {\n            let subEntry = (await this.dbRequest('get', [e]));\n            if (subEntry === undefined) {\n                subEntry = (await this.dbRequest('get', [e + '/']));\n            }\n            return {\n                name: e.substring(path.length + 1),\n                type: subEntry.type,\n                size: subEntry.size,\n                ctime: subEntry.ctime,\n                mtime: subEntry.mtime,\n                uri: subEntry.path,\n            };\n        }));\n        return { files: files };\n    }\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    async getUri(options) {\n        const path = this.getPath(options.directory, options.path);\n        let entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined) {\n            entry = (await this.dbRequest('get', [path + '/']));\n        }\n        return {\n            uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path,\n        };\n    }\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    async stat(options) {\n        const path = this.getPath(options.directory, options.path);\n        let entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined) {\n            entry = (await this.dbRequest('get', [path + '/']));\n        }\n        if (entry === undefined)\n            throw Error('Entry does not exist.');\n        return {\n            name: entry.path.substring(path.length + 1),\n            type: entry.type,\n            size: entry.size,\n            ctime: entry.ctime,\n            mtime: entry.mtime,\n            uri: entry.path,\n        };\n    }\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n    async rename(options) {\n        await this._copy(options, true);\n        return;\n    }\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n    async copy(options) {\n        return this._copy(options, false);\n    }\n    async requestPermissions() {\n        return { publicStorage: 'granted' };\n    }\n    async checkPermissions() {\n        return { publicStorage: 'granted' };\n    }\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n    async _copy(options, doRename = false) {\n        let { toDirectory } = options;\n        const { to, from, directory: fromDirectory } = options;\n        if (!to || !from) {\n            throw Error('Both to and from must be provided');\n        }\n        // If no \"to\" directory is provided, use the \"from\" directory\n        if (!toDirectory) {\n            toDirectory = fromDirectory;\n        }\n        const fromPath = this.getPath(fromDirectory, from);\n        const toPath = this.getPath(toDirectory, to);\n        // Test that the \"to\" and \"from\" locations are different\n        if (fromPath === toPath) {\n            return {\n                uri: toPath,\n            };\n        }\n        if (isPathParent(fromPath, toPath)) {\n            throw Error('To path cannot contain the from path');\n        }\n        // Check the state of the \"to\" location\n        let toObj;\n        try {\n            toObj = await this.stat({\n                path: to,\n                directory: toDirectory,\n            });\n        }\n        catch (e) {\n            // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n            const toPathComponents = to.split('/');\n            toPathComponents.pop();\n            const toPath = toPathComponents.join('/');\n            // Check the containing directory of the \"to\" location exists\n            if (toPathComponents.length > 0) {\n                const toParentDirectory = await this.stat({\n                    path: toPath,\n                    directory: toDirectory,\n                });\n                if (toParentDirectory.type !== 'directory') {\n                    throw new Error('Parent directory of the to path is a file');\n                }\n            }\n        }\n        // Cannot overwrite a directory\n        if (toObj && toObj.type === 'directory') {\n            throw new Error('Cannot overwrite a directory with a file');\n        }\n        // Ensure the \"from\" object exists\n        const fromObj = await this.stat({\n            path: from,\n            directory: fromDirectory,\n        });\n        // Set the mtime/ctime of the supplied path\n        const updateTime = async (path, ctime, mtime) => {\n            const fullPath = this.getPath(toDirectory, path);\n            const entry = (await this.dbRequest('get', [fullPath]));\n            entry.ctime = ctime;\n            entry.mtime = mtime;\n            await this.dbRequest('put', [entry]);\n        };\n        const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n        switch (fromObj.type) {\n            // The \"from\" object is a file\n            case 'file': {\n                // Read the file\n                const file = await this.readFile({\n                    path: from,\n                    directory: fromDirectory,\n                });\n                // Optionally remove the file\n                if (doRename) {\n                    await this.deleteFile({\n                        path: from,\n                        directory: fromDirectory,\n                    });\n                }\n                let encoding;\n                if (!(file.data instanceof Blob) && !this.isBase64String(file.data)) {\n                    encoding = _definitions__WEBPACK_IMPORTED_MODULE_1__.Encoding.UTF8;\n                }\n                // Write the file to the new location\n                const writeResult = await this.writeFile({\n                    path: to,\n                    directory: toDirectory,\n                    data: file.data,\n                    encoding: encoding,\n                });\n                // Copy the mtime/ctime of a renamed file\n                if (doRename) {\n                    await updateTime(to, ctime, fromObj.mtime);\n                }\n                // Resolve promise\n                return writeResult;\n            }\n            case 'directory': {\n                if (toObj) {\n                    throw Error('Cannot move a directory over an existing object');\n                }\n                try {\n                    // Create the to directory\n                    await this.mkdir({\n                        path: to,\n                        directory: toDirectory,\n                        recursive: false,\n                    });\n                    // Copy the mtime/ctime of a renamed directory\n                    if (doRename) {\n                        await updateTime(to, ctime, fromObj.mtime);\n                    }\n                }\n                catch (e) {\n                    // ignore\n                }\n                // Iterate over the contents of the from location\n                const contents = (await this.readdir({\n                    path: from,\n                    directory: fromDirectory,\n                })).files;\n                for (const filename of contents) {\n                    // Move item from the from directory to the to directory\n                    await this._copy({\n                        from: `${from}/${filename.name}`,\n                        to: `${to}/${filename.name}`,\n                        directory: fromDirectory,\n                        toDirectory,\n                    }, doRename);\n                }\n                // Optionally remove the original from directory\n                if (doRename) {\n                    await this.rmdir({\n                        path: from,\n                        directory: fromDirectory,\n                    });\n                }\n            }\n        }\n        return {\n            uri: toPath,\n        };\n    }\n    isBase64String(str) {\n        try {\n            return btoa(atob(str)) == str;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n}\nFilesystemWeb._debug = true;\n//# sourceMappingURL=web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9maWxlc3lzdGVtL2Rpc3QvZXNtL3dlYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDckI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLHNEQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUVBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0NBQWdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSyxHQUFHLFdBQVc7QUFDcEQsK0NBQStDLDRCQUE0QjtBQUMzRTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUssR0FBRyxjQUFjO0FBQ3ZELCtCQUErQixHQUFHLEdBQUcsY0FBYztBQUNuRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maW5hbmNpYWwtZGFzaGJvYXJkLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2ZpbGVzeXN0ZW0vZGlzdC9lc20vd2ViLmpzPzhmZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2ViUGx1Z2luLCBidWlsZFJlcXVlc3RJbml0IH0gZnJvbSAnQGNhcGFjaXRvci9jb3JlJztcbmltcG9ydCB7IEVuY29kaW5nIH0gZnJvbSAnLi9kZWZpbml0aW9ucyc7XG5mdW5jdGlvbiByZXNvbHZlKHBhdGgpIHtcbiAgICBjb25zdCBwb3NpeCA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09ICcuJyk7XG4gICAgY29uc3QgbmV3UG9zaXggPSBbXTtcbiAgICBwb3NpeC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtID09PSAnLi4nICYmIG5ld1Bvc2l4Lmxlbmd0aCA+IDAgJiYgbmV3UG9zaXhbbmV3UG9zaXgubGVuZ3RoIC0gMV0gIT09ICcuLicpIHtcbiAgICAgICAgICAgIG5ld1Bvc2l4LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UG9zaXgucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdQb3NpeC5qb2luKCcvJyk7XG59XG5mdW5jdGlvbiBpc1BhdGhQYXJlbnQocGFyZW50LCBjaGlsZHJlbikge1xuICAgIHBhcmVudCA9IHJlc29sdmUocGFyZW50KTtcbiAgICBjaGlsZHJlbiA9IHJlc29sdmUoY2hpbGRyZW4pO1xuICAgIGNvbnN0IHBhdGhzQSA9IHBhcmVudC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHBhdGhzQiA9IGNoaWxkcmVuLnNwbGl0KCcvJyk7XG4gICAgcmV0dXJuIHBhcmVudCAhPT0gY2hpbGRyZW4gJiYgcGF0aHNBLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBwYXRoc0JbaW5kZXhdKTtcbn1cbmV4cG9ydCBjbGFzcyBGaWxlc3lzdGVtV2ViIGV4dGVuZHMgV2ViUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5EQl9WRVJTSU9OID0gMTtcbiAgICAgICAgdGhpcy5EQl9OQU1FID0gJ0Rpc2MnO1xuICAgICAgICB0aGlzLl93cml0ZUNtZHMgPSBbJ2FkZCcsICdwdXQnLCAnZGVsZXRlJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgaHR0cCByZXF1ZXN0IHRvIGEgc2VydmVyIGFuZCBkb3dubG9hZHMgdGhlIGZpbGUgdG8gdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEBjYXBhY2l0b3IvZmlsZS10cmFuc2ZlciBwbHVnaW4gaW5zdGVhZC5cbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBkb3dubG9hZCBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZG93bmxvYWQgZmlsZSByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG93bmxvYWRGaWxlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5pdCA9IGJ1aWxkUmVxdWVzdEluaXQob3B0aW9ucywgb3B0aW9ucy53ZWJGZXRjaEV4dHJhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gob3B0aW9ucy51cmwsIHJlcXVlc3RJbml0KTtcbiAgICAgICAgICAgIGxldCBibG9iO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBlbHNlIGlmICghKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSlcbiAgICAgICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGVzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykgfHwgJzAnLCAxMCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBieXRlcyArPSAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoJ3Byb2dyZXNzJywgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYWxsQ2h1bmtzLnNldChjaHVuaywgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbYWxsQ2h1bmtzLmJ1ZmZlcl0sIHsgdHlwZTogY29udGVudFR5cGUgfHwgdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy53cml0ZUZpbGUoe1xuICAgICAgICAgICAgICAgIHBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IChfYSA9IG9wdGlvbnMuZGlyZWN0b3J5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlOiAoX2IgPSBvcHRpb25zLnJlY3Vyc2l2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogYmxvYixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogcmVzdWx0LnVyaSwgYmxvYiB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWFkRmlsZUluQ2h1bmtzKF9vcHRpb25zLCBfY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgdGhpcy51bmF2YWlsYWJsZSgnTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdERiKCkge1xuICAgICAgICBpZiAodGhpcy5fZGIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKCdpbmRleGVkREInIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5hdmFpbGFibGUoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEluZGV4ZWREQlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuREJfTkFNRSwgdGhpcy5EQl9WRVJTSU9OKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gRmlsZXN5c3RlbVdlYi5kb1VwZ3JhZGU7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZGIgYmxvY2tlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBkb1VwZ3JhZGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGRiID0gZXZlbnRUYXJnZXQucmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKGV2ZW50Lm9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnRmlsZVN0b3JhZ2UnKSkge1xuICAgICAgICAgICAgICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSgnRmlsZVN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZSgnRmlsZVN0b3JhZ2UnLCB7IGtleVBhdGg6ICdwYXRoJyB9KTtcbiAgICAgICAgICAgICAgICBzdG9yZS5jcmVhdGVJbmRleCgnYnlfZm9sZGVyJywgJ2ZvbGRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRiUmVxdWVzdChjbWQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVhZEZsYWcgPSB0aGlzLl93cml0ZUNtZHMuaW5kZXhPZihjbWQpICE9PSAtMSA/ICdyZWFkd3JpdGUnIDogJ3JlYWRvbmx5JztcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdERiKCkudGhlbigoY29ubikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGNvbm4udHJhbnNhY3Rpb24oWydGaWxlU3RvcmFnZSddLCByZWFkRmxhZyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZSgnRmlsZVN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZVtjbWRdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRiSW5kZXhSZXF1ZXN0KGluZGV4TmFtZSwgY21kLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlYWRGbGFnID0gdGhpcy5fd3JpdGVDbWRzLmluZGV4T2YoY21kKSAhPT0gLTEgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seSc7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXREYigpLnRoZW4oKGNvbm4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBjb25uLnRyYW5zYWN0aW9uKFsnRmlsZVN0b3JhZ2UnXSwgcmVhZEZsYWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHgub2JqZWN0U3RvcmUoJ0ZpbGVTdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IGluZGV4W2NtZF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGF0aChkaXJlY3RvcnksIHVyaVBhdGgpIHtcbiAgICAgICAgY29uc3QgY2xlYW5lZFVyaVBhdGggPSB1cmlQYXRoICE9PSB1bmRlZmluZWQgPyB1cmlQYXRoLnJlcGxhY2UoL15bL10rfFsvXSskL2csICcnKSA6ICcnO1xuICAgICAgICBsZXQgZnNQYXRoID0gJyc7XG4gICAgICAgIGlmIChkaXJlY3RvcnkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZzUGF0aCArPSAnLycgKyBkaXJlY3Rvcnk7XG4gICAgICAgIGlmICh1cmlQYXRoICE9PSAnJylcbiAgICAgICAgICAgIGZzUGF0aCArPSAnLycgKyBjbGVhbmVkVXJpUGF0aDtcbiAgICAgICAgcmV0dXJuIGZzUGF0aDtcbiAgICB9XG4gICAgYXN5bmMgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCB0aGlzLmluaXREYigpO1xuICAgICAgICBjb25zdCB0eCA9IGNvbm4udHJhbnNhY3Rpb24oWydGaWxlU3RvcmFnZSddLCAncmVhZHdyaXRlJyk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHgub2JqZWN0U3RvcmUoJ0ZpbGVTdG9yYWdlJyk7XG4gICAgICAgIHN0b3JlLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBmaWxlIGZyb20gZGlza1xuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHJlYWRcbiAgICAgKiBAcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlYWQgZmlsZSBkYXRhIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRGaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZ2V0UGF0aChvcHRpb25zLmRpcmVjdG9yeSwgb3B0aW9ucy5wYXRoKTtcbiAgICAgICAgLy8gY29uc3QgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICAgICAgICBjb25zdCBlbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGhdKSk7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZpbGUgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGVudHJ5LmNvbnRlbnQgPyBlbnRyeS5jb250ZW50IDogJycgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBmaWxlIHRvIGRpc2sgaW4gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBvbiBkZXZpY2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGUgZmlsZSB3cml0ZVxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZmlsZSB3cml0ZSByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZUZpbGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRQYXRoKG9wdGlvbnMuZGlyZWN0b3J5LCBvcHRpb25zLnBhdGgpO1xuICAgICAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICAgICAgICBjb25zdCBkb1JlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlO1xuICAgICAgICBjb25zdCBvY2N1cGllZEVudHJ5ID0gKGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdnZXQnLCBbcGF0aF0pKTtcbiAgICAgICAgaWYgKG9jY3VwaWVkRW50cnkgJiYgb2NjdXBpZWRFbnRyeS50eXBlID09PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgc3VwcGxpZWQgcGF0aCBpcyBhIGRpcmVjdG9yeS4nKTtcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgIGNvbnN0IHBhcmVudEVudHJ5ID0gKGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdnZXQnLCBbcGFyZW50UGF0aF0pKTtcbiAgICAgICAgaWYgKHBhcmVudEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkRpckluZGV4ID0gcGFyZW50UGF0aC5pbmRleE9mKCcvJywgMSk7XG4gICAgICAgICAgICBpZiAoc3ViRGlySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50QXJnUGF0aCA9IHBhcmVudFBhdGguc3Vic3RyKHN1YkRpckluZGV4KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyZW50QXJnUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiBvcHRpb25zLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlOiBkb1JlY3Vyc2l2ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVuY29kaW5nICYmICEoZGF0YSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5pbmRleE9mKCcsJykgPj0gMCA/IGRhdGEuc3BsaXQoJywnKVsxXSA6IGRhdGE7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNCYXNlNjRTdHJpbmcoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSBzdXBwbGllZCBkYXRhIGlzIG5vdCB2YWxpZCBiYXNlNjQgY29udGVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBwYXRoT2JqID0ge1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIGZvbGRlcjogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgIHNpemU6IGRhdGEgaW5zdGFuY2VvZiBCbG9iID8gZGF0YS5zaXplIDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBjdGltZTogbm93LFxuICAgICAgICAgICAgbXRpbWU6IG5vdyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdwdXQnLCBbcGF0aE9ial0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJpOiBwYXRoT2JqLnBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZCB0byBhIGZpbGUgb24gZGlzayBpbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIG9uIGRldmljZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoZSBmaWxlIGFwcGVuZFxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZmlsZSB3cml0ZSByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBhcHBlbmRGaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZ2V0UGF0aChvcHRpb25zLmRpcmVjdG9yeSwgb3B0aW9ucy5wYXRoKTtcbiAgICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBjdGltZSA9IG5vdztcbiAgICAgICAgY29uc3Qgb2NjdXBpZWRFbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGhdKSk7XG4gICAgICAgIGlmIChvY2N1cGllZEVudHJ5ICYmIG9jY3VwaWVkRW50cnkudHlwZSA9PT0gJ2RpcmVjdG9yeScpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHN1cHBsaWVkIHBhdGggaXMgYSBkaXJlY3RvcnkuJyk7XG4gICAgICAgIGNvbnN0IHBhcmVudEVudHJ5ID0gKGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdnZXQnLCBbcGFyZW50UGF0aF0pKTtcbiAgICAgICAgaWYgKHBhcmVudEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkRpckluZGV4ID0gcGFyZW50UGF0aC5pbmRleE9mKCcvJywgMSk7XG4gICAgICAgICAgICBpZiAoc3ViRGlySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50QXJnUGF0aCA9IHBhcmVudFBhdGguc3Vic3RyKHN1YkRpckluZGV4KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyZW50QXJnUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiBvcHRpb25zLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZW5jb2RpbmcgJiYgIXRoaXMuaXNCYXNlNjRTdHJpbmcoZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHN1cHBsaWVkIGRhdGEgaXMgbm90IHZhbGlkIGJhc2U2NCBjb250ZW50LicpO1xuICAgICAgICBpZiAob2NjdXBpZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob2NjdXBpZWRFbnRyeS5jb250ZW50IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgb2NjdXBpZWQgZW50cnkgY29udGFpbnMgYSBCbG9iIG9iamVjdCB3aGljaCBjYW5ub3QgYmUgYXBwZW5kZWQgdG8uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2NjdXBpZWRFbnRyeS5jb250ZW50ICE9PSB1bmRlZmluZWQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGJ0b2EoYXRvYihvY2N1cGllZEVudHJ5LmNvbnRlbnQpICsgYXRvYihkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gb2NjdXBpZWRFbnRyeS5jb250ZW50ICsgZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0aW1lID0gb2NjdXBpZWRFbnRyeS5jdGltZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoT2JqID0ge1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIGZvbGRlcjogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgIHNpemU6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgY3RpbWU6IGN0aW1lLFxuICAgICAgICAgICAgbXRpbWU6IG5vdyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdwdXQnLCBbcGF0aE9ial0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlIGZyb20gZGlza1xuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoZSBmaWxlIGRlbGV0ZVxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZGVsZXRlZCBmaWxlIGRhdGEgcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlRmlsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldFBhdGgob3B0aW9ucy5kaXJlY3RvcnksIG9wdGlvbnMucGF0aCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gKGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdnZXQnLCBbcGF0aF0pKTtcbiAgICAgICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRmlsZSBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMuZGJJbmRleFJlcXVlc3QoJ2J5X2ZvbGRlcicsICdnZXRBbGxLZXlzJywgW0lEQktleVJhbmdlLm9ubHkocGF0aCldKTtcbiAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZvbGRlciBpcyBub3QgZW1wdHkuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdkZWxldGUnLCBbcGF0aF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkaXJlY3RvcnkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhlIG1rZGlyXG4gICAgICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBta2RpciByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBta2RpcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldFBhdGgob3B0aW9ucy5kaXJlY3RvcnksIG9wdGlvbnMucGF0aCk7XG4gICAgICAgIGNvbnN0IGRvUmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmU7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICBjb25zdCBkZXB0aCA9IChwYXRoLm1hdGNoKC9cXC8vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGFyZW50RW50cnkgPSAoYXdhaXQgdGhpcy5kYlJlcXVlc3QoJ2dldCcsIFtwYXJlbnRQYXRoXSkpO1xuICAgICAgICBjb25zdCBvY2N1cGllZEVudHJ5ID0gKGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdnZXQnLCBbcGF0aF0pKTtcbiAgICAgICAgaWYgKGRlcHRoID09PSAxKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgUm9vdCBkaXJlY3RvcnknKTtcbiAgICAgICAgaWYgKG9jY3VwaWVkRW50cnkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDdXJyZW50IGRpcmVjdG9yeSBkb2VzIGFscmVhZHkgZXhpc3QuJyk7XG4gICAgICAgIGlmICghZG9SZWN1cnNpdmUgJiYgZGVwdGggIT09IDIgJiYgcGFyZW50RW50cnkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdQYXJlbnQgZGlyZWN0b3J5IG11c3QgZXhpc3QnKTtcbiAgICAgICAgaWYgKGRvUmVjdXJzaXZlICYmIGRlcHRoICE9PSAyICYmIHBhcmVudEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEFyZ1BhdGggPSBwYXJlbnRQYXRoLnN1YnN0cihwYXJlbnRQYXRoLmluZGV4T2YoJy8nLCAxKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXJlbnRBcmdQYXRoLFxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogb3B0aW9ucy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlOiBkb1JlY3Vyc2l2ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHBhdGhPYmogPSB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgZm9sZGVyOiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgdHlwZTogJ2RpcmVjdG9yeScsXG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY3RpbWU6IG5vdyxcbiAgICAgICAgICAgIG10aW1lOiBub3csXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdwdXQnLCBbcGF0aE9ial0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIGRpcmVjdG9yeSByZW1vdmVcbiAgICAgKi9cbiAgICBhc3luYyBybWRpcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aCwgZGlyZWN0b3J5LCByZWN1cnNpdmUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy5nZXRQYXRoKGRpcmVjdG9yeSwgcGF0aCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gKGF3YWl0IHRoaXMuZGJSZXF1ZXN0KCdnZXQnLCBbZnVsbFBhdGhdKSk7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZvbGRlciBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgIT09ICdkaXJlY3RvcnknKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlcXVlc3RlZCBwYXRoIGlzIG5vdCBhIGRpcmVjdG9yeScpO1xuICAgICAgICBjb25zdCByZWFkRGlyUmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZGlyKHsgcGF0aCwgZGlyZWN0b3J5IH0pO1xuICAgICAgICBpZiAocmVhZERpclJlc3VsdC5maWxlcy5sZW5ndGggIT09IDAgJiYgIXJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdGb2xkZXIgaXMgbm90IGVtcHR5Jyk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVhZERpclJlc3VsdC5maWxlcykge1xuICAgICAgICAgICAgY29uc3QgZW50cnlQYXRoID0gYCR7cGF0aH0vJHtlbnRyeS5uYW1lfWA7XG4gICAgICAgICAgICBjb25zdCBlbnRyeU9iaiA9IGF3YWl0IHRoaXMuc3RhdCh7IHBhdGg6IGVudHJ5UGF0aCwgZGlyZWN0b3J5IH0pO1xuICAgICAgICAgICAgaWYgKGVudHJ5T2JqLnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVsZXRlRmlsZSh7IHBhdGg6IGVudHJ5UGF0aCwgZGlyZWN0b3J5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ybWRpcih7IHBhdGg6IGVudHJ5UGF0aCwgZGlyZWN0b3J5LCByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5kYlJlcXVlc3QoJ2RlbGV0ZScsIFtmdWxsUGF0aF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBsaXN0IG9mIGZpbGVzIGZyb20gdGhlIGRpcmVjdG9yeSAobm90IHJlY3Vyc2l2ZSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIHJlYWRkaXIgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZWFkZGlyIGRpcmVjdG9yeSBsaXN0aW5nIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRkaXIob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRQYXRoKG9wdGlvbnMuZGlyZWN0b3J5LCBvcHRpb25zLnBhdGgpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGhdKSk7XG4gICAgICAgIGlmIChvcHRpb25zLnBhdGggIT09ICcnICYmIGVudHJ5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRm9sZGVyIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgdGhpcy5kYkluZGV4UmVxdWVzdCgnYnlfZm9sZGVyJywgJ2dldEFsbEtleXMnLCBbSURCS2V5UmFuZ2Uub25seShwYXRoKV0pO1xuICAgICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKGVudHJpZXMubWFwKGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3ViRW50cnkgPSAoYXdhaXQgdGhpcy5kYlJlcXVlc3QoJ2dldCcsIFtlXSkpO1xuICAgICAgICAgICAgaWYgKHN1YkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJFbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW2UgKyAnLyddKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGUuc3Vic3RyaW5nKHBhdGgubGVuZ3RoICsgMSksXG4gICAgICAgICAgICAgICAgdHlwZTogc3ViRW50cnkudHlwZSxcbiAgICAgICAgICAgICAgICBzaXplOiBzdWJFbnRyeS5zaXplLFxuICAgICAgICAgICAgICAgIGN0aW1lOiBzdWJFbnRyeS5jdGltZSxcbiAgICAgICAgICAgICAgICBtdGltZTogc3ViRW50cnkubXRpbWUsXG4gICAgICAgICAgICAgICAgdXJpOiBzdWJFbnRyeS5wYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyBmaWxlczogZmlsZXMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZ1bGwgRmlsZSBVUkkgZm9yIGEgcGF0aCBhbmQgZGlyZWN0b3J5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzdGF0IG9wZXJhdGlvblxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZmlsZSBzdGF0IHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFVyaShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldFBhdGgob3B0aW9ucy5kaXJlY3RvcnksIG9wdGlvbnMucGF0aCk7XG4gICAgICAgIGxldCBlbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGhdKSk7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGggKyAnLyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVyaTogKGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5wYXRoKSB8fCBwYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZGF0YSBhYm91dCBhIGZpbGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIHN0YXQgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaWxlIHN0YXQgcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgc3RhdChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldFBhdGgob3B0aW9ucy5kaXJlY3RvcnksIG9wdGlvbnMucGF0aCk7XG4gICAgICAgIGxldCBlbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGhdKSk7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbnRyeSA9IChhd2FpdCB0aGlzLmRiUmVxdWVzdCgnZ2V0JywgW3BhdGggKyAnLyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRW50cnkgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlbnRyeS5wYXRoLnN1YnN0cmluZyhwYXRoLmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgIHNpemU6IGVudHJ5LnNpemUsXG4gICAgICAgICAgICBjdGltZTogZW50cnkuY3RpbWUsXG4gICAgICAgICAgICBtdGltZTogZW50cnkubXRpbWUsXG4gICAgICAgICAgICB1cmk6IGVudHJ5LnBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmFtZSBhIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoZSByZW5hbWUgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZW5hbWUgcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgcmVuYW1lKG9wdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29weShvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgZmlsZSBvciBkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNvcHkgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb3B5IHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGNvcHkob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29weShvcHRpb25zLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RQZXJtaXNzaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHsgcHVibGljU3RvcmFnZTogJ2dyYW50ZWQnIH07XG4gICAgfVxuICAgIGFzeW5jIGNoZWNrUGVybWlzc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB7IHB1YmxpY1N0b3JhZ2U6ICdncmFudGVkJyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGNhbiBwZXJmb3JtIGEgY29weSBvciBhIHJlbmFtZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIGZvciB0aGUgcmVuYW1lIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBkb1JlbmFtZSB3aGV0aGVyIHRvIHBlcmZvcm0gYSByZW5hbWUgb3IgY29weSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIF9jb3B5KG9wdGlvbnMsIGRvUmVuYW1lID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHsgdG9EaXJlY3RvcnkgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGRpcmVjdG9yeTogZnJvbURpcmVjdG9yeSB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCF0byB8fCAhZnJvbSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0JvdGggdG8gYW5kIGZyb20gbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIFwidG9cIiBkaXJlY3RvcnkgaXMgcHJvdmlkZWQsIHVzZSB0aGUgXCJmcm9tXCIgZGlyZWN0b3J5XG4gICAgICAgIGlmICghdG9EaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIHRvRGlyZWN0b3J5ID0gZnJvbURpcmVjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tUGF0aCA9IHRoaXMuZ2V0UGF0aChmcm9tRGlyZWN0b3J5LCBmcm9tKTtcbiAgICAgICAgY29uc3QgdG9QYXRoID0gdGhpcy5nZXRQYXRoKHRvRGlyZWN0b3J5LCB0byk7XG4gICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgXCJ0b1wiIGFuZCBcImZyb21cIiBsb2NhdGlvbnMgYXJlIGRpZmZlcmVudFxuICAgICAgICBpZiAoZnJvbVBhdGggPT09IHRvUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmk6IHRvUGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUGF0aFBhcmVudChmcm9tUGF0aCwgdG9QYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RvIHBhdGggY2Fubm90IGNvbnRhaW4gdGhlIGZyb20gcGF0aCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoZSBzdGF0ZSBvZiB0aGUgXCJ0b1wiIGxvY2F0aW9uXG4gICAgICAgIGxldCB0b09iajtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRvT2JqID0gYXdhaXQgdGhpcy5zdGF0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiB0byxcbiAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IHRvRGlyZWN0b3J5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRvIGxvY2F0aW9uIGRvZXMgbm90IGV4aXN0LCBlbnN1cmUgdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIFwidG9cIiBsb2NhdGlvbiBleGlzdHMgYW5kIGlzIGEgZGlyZWN0b3J5XG4gICAgICAgICAgICBjb25zdCB0b1BhdGhDb21wb25lbnRzID0gdG8uc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIHRvUGF0aENvbXBvbmVudHMucG9wKCk7XG4gICAgICAgICAgICBjb25zdCB0b1BhdGggPSB0b1BhdGhDb21wb25lbnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjb250YWluaW5nIGRpcmVjdG9yeSBvZiB0aGUgXCJ0b1wiIGxvY2F0aW9uIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHRvUGF0aENvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvUGFyZW50RGlyZWN0b3J5ID0gYXdhaXQgdGhpcy5zdGF0KHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogdG9QYXRoLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IHRvRGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0b1BhcmVudERpcmVjdG9yeS50eXBlICE9PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBkaXJlY3Rvcnkgb2YgdGhlIHRvIHBhdGggaXMgYSBmaWxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbm5vdCBvdmVyd3JpdGUgYSBkaXJlY3RvcnlcbiAgICAgICAgaWYgKHRvT2JqICYmIHRvT2JqLnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVyd3JpdGUgYSBkaXJlY3Rvcnkgd2l0aCBhIGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIFwiZnJvbVwiIG9iamVjdCBleGlzdHNcbiAgICAgICAgY29uc3QgZnJvbU9iaiA9IGF3YWl0IHRoaXMuc3RhdCh7XG4gICAgICAgICAgICBwYXRoOiBmcm9tLFxuICAgICAgICAgICAgZGlyZWN0b3J5OiBmcm9tRGlyZWN0b3J5LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IHRoZSBtdGltZS9jdGltZSBvZiB0aGUgc3VwcGxpZWQgcGF0aFxuICAgICAgICBjb25zdCB1cGRhdGVUaW1lID0gYXN5bmMgKHBhdGgsIGN0aW1lLCBtdGltZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSB0aGlzLmdldFBhdGgodG9EaXJlY3RvcnksIHBhdGgpO1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSAoYXdhaXQgdGhpcy5kYlJlcXVlc3QoJ2dldCcsIFtmdWxsUGF0aF0pKTtcbiAgICAgICAgICAgIGVudHJ5LmN0aW1lID0gY3RpbWU7XG4gICAgICAgICAgICBlbnRyeS5tdGltZSA9IG10aW1lO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kYlJlcXVlc3QoJ3B1dCcsIFtlbnRyeV0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjdGltZSA9IGZyb21PYmouY3RpbWUgPyBmcm9tT2JqLmN0aW1lIDogRGF0ZS5ub3coKTtcbiAgICAgICAgc3dpdGNoIChmcm9tT2JqLnR5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBcImZyb21cIiBvYmplY3QgaXMgYSBmaWxlXG4gICAgICAgICAgICBjYXNlICdmaWxlJzoge1xuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5yZWFkRmlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogZnJvbURpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IHJlbW92ZSB0aGUgZmlsZVxuICAgICAgICAgICAgICAgIGlmIChkb1JlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZUZpbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogZnJvbURpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgICAgICAgICBpZiAoIShmaWxlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSAmJiAhdGhpcy5pc0Jhc2U2NFN0cmluZyhmaWxlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gRW5jb2RpbmcuVVRGODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGZpbGUgdG8gdGhlIG5ldyBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlUmVzdWx0ID0gYXdhaXQgdGhpcy53cml0ZUZpbGUoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiB0byxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiB0b0RpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmlsZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgbXRpbWUvY3RpbWUgb2YgYSByZW5hbWVkIGZpbGVcbiAgICAgICAgICAgICAgICBpZiAoZG9SZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlVGltZSh0bywgY3RpbWUsIGZyb21PYmoubXRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHByb21pc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RvcnknOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgbW92ZSBhIGRpcmVjdG9yeSBvdmVyIGFuIGV4aXN0aW5nIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRvIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiB0b0RpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBtdGltZS9jdGltZSBvZiBhIHJlbmFtZWQgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb1JlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlVGltZSh0bywgY3RpbWUsIGZyb21PYmoubXRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGNvbnRlbnRzIG9mIHRoZSBmcm9tIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSAoYXdhaXQgdGhpcy5yZWFkZGlyKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiBmcm9tRGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgIH0pKS5maWxlcztcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGVuYW1lIG9mIGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgaXRlbSBmcm9tIHRoZSBmcm9tIGRpcmVjdG9yeSB0byB0aGUgdG8gZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NvcHkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYCR7ZnJvbX0vJHtmaWxlbmFtZS5uYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogYCR7dG99LyR7ZmlsZW5hbWUubmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiBmcm9tRGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9EaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgIH0sIGRvUmVuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSByZW1vdmUgdGhlIG9yaWdpbmFsIGZyb20gZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgaWYgKGRvUmVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucm1kaXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogZnJvbURpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmk6IHRvUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaXNCYXNlNjRTdHJpbmcoc3RyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShhdG9iKHN0cikpID09IHN0cjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5GaWxlc3lzdGVtV2ViLl9kZWJ1ZyA9IHRydWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/filesystem/dist/esm/web.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/synapse/dist/synapse.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@capacitor/synapse/dist/synapse.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exposeSynapse: () => (/* binding */ f)\n/* harmony export */ });\nfunction s(t) {\n  t.CapacitorUtils.Synapse = new Proxy(\n    {},\n    {\n      get(e, n) {\n        return new Proxy({}, {\n          get(w, o) {\n            return (c, p, r) => {\n              const i = t.Capacitor.Plugins[n];\n              if (i === void 0) {\n                r(new Error(`Capacitor plugin ${n} not found`));\n                return;\n              }\n              if (typeof i[o] != \"function\") {\n                r(new Error(`Method ${o} not found in Capacitor plugin ${n}`));\n                return;\n              }\n              (async () => {\n                try {\n                  const a = await i[o](c);\n                  p(a);\n                } catch (a) {\n                  r(a);\n                }\n              })();\n            };\n          }\n        });\n      }\n    }\n  );\n}\nfunction u(t) {\n  t.CapacitorUtils.Synapse = new Proxy(\n    {},\n    {\n      get(e, n) {\n        return t.cordova.plugins[n];\n      }\n    }\n  );\n}\nfunction f(t = !1) {\n  typeof window > \"u\" || (window.CapacitorUtils = window.CapacitorUtils || {}, window.Capacitor !== void 0 && !t ? s(window) : window.cordova !== void 0 && u(window));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9zeW5hcHNlL2Rpc3Qvc3luYXBzZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxHQUFHLGdDQUFnQyxFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpbmFuY2lhbC1kYXNoYm9hcmQtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BjYXBhY2l0b3Ivc3luYXBzZS9kaXN0L3N5bmFwc2UubWpzPzg5MWEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcyh0KSB7XG4gIHQuQ2FwYWNpdG9yVXRpbHMuU3luYXBzZSA9IG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICBnZXQoZSwgbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgZ2V0KHcsIG8pIHtcbiAgICAgICAgICAgIHJldHVybiAoYywgcCwgcikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpID0gdC5DYXBhY2l0b3IuUGx1Z2luc1tuXTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHIobmV3IEVycm9yKGBDYXBhY2l0b3IgcGx1Z2luICR7bn0gbm90IGZvdW5kYCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGlbb10gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcihuZXcgRXJyb3IoYE1ldGhvZCAke299IG5vdCBmb3VuZCBpbiBDYXBhY2l0b3IgcGx1Z2luICR7bn1gKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBhd2FpdCBpW29dKGMpO1xuICAgICAgICAgICAgICAgICAgcChhKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgICAgICAgICAgICByKGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB1KHQpIHtcbiAgdC5DYXBhY2l0b3JVdGlscy5TeW5hcHNlID0gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGdldChlLCBuKSB7XG4gICAgICAgIHJldHVybiB0LmNvcmRvdmEucGx1Z2luc1tuXTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBmKHQgPSAhMSkge1xuICB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgfHwgKHdpbmRvdy5DYXBhY2l0b3JVdGlscyA9IHdpbmRvdy5DYXBhY2l0b3JVdGlscyB8fCB7fSwgd2luZG93LkNhcGFjaXRvciAhPT0gdm9pZCAwICYmICF0ID8gcyh3aW5kb3cpIDogd2luZG93LmNvcmRvdmEgIT09IHZvaWQgMCAmJiB1KHdpbmRvdykpO1xufVxuZXhwb3J0IHtcbiAgZiBhcyBleHBvc2VTeW5hcHNlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/synapse/dist/synapse.mjs\n");

/***/ })

};
;